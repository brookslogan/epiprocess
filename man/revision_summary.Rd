% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/revision_analysis.R
\name{revision_summary}
\alias{revision_summary}
\title{A function to describe revision behavior for an archive}
\usage{
revision_summary(
  epi_arch,
  ...,
  drop_nas = TRUE,
  percent_final_value = 0.8,
  print_inform = TRUE,
  quick_revision = as.difftime(3, units = "days"),
  few_revisions = 3,
  rel_change_threshold = 0.1,
  abs_change_threshold = NULL
)
}
\arguments{
\item{epi_arch}{an epi_archive to be analyzed}

\item{...}{tidyselect, used to choose the column to summarize. If empty, it
chooses the first. Currently only implemented for one column at a time}

\item{print_inform}{bool, determines whether to print summary information, or
only return the full summary tibble}

\item{quick_revision}{difftime or integer (integer is treated as days), for
the printed summary, the amount of time between the final revision and the
actual time_value to consider the revision quickly resolved. Default of 3
days}

\item{few_revisions}{integer, for the printed summary, the upper bound on the
number of revisions to consider "few". Default is 3.}

\item{abs_threshold}{numeric, for the printed summary, the maximum change
used to characterize revisions which don't actually change very much.
Default is 5\% of the maximum value in the dataset, but this is the most
unit dependent of values, and likely needs to be chosen appropriate for the
scale of the dataset}

\item{rel_threshold}{float between 0 and 1, for the printed summary, the
relative change fraction used to characterize revisions which don't
actually change very much. Default is .1, or 10\% of the final value}
}
\description{
\code{revision_summary} removes all missing values, and then computes some basic
statistics about the revision behavior of an archive, returning a tibble of
a per-epi-key (so time_value, geo_value pair, possibly others based on the
metadata). If \code{print_inform} is true, it prints a concise summary. The
columns returned are:
\enumerate{
\item \code{min_lag}: the minimum time to any value (if \code{drop_nas=FALSE}, this
includes \code{NA}'s)
\item \code{max_lag}: the amount of time until the final (new) version (same caveat
for \code{drop_nas=FALSE}, though it is far less likely to matter)
\item \code{max_change}: the difference between the smallest and largest values (this
always excludes \code{NA} values)
\item \code{max_rel_change}: \code{max_change} divided by the largest value (so it will
always be less than 1). Note that this need not be the final value. It will
be \code{NA} whenever \code{max_change} is 0.
\item \code{time_to_x_final}: where \code{x} is the \code{percent_final_value} (default). This
gives the lag when the value is within \code{1-x} of the value at the final
time. For example, consider the series (0,20, 99, 150, 102, 100); then
\code{time_to_x_final} is the 5th index, since even though 99 is within 20\%, it
is outside the window afterwards at 150.
epi_arch$DT \%>\% filter(time_value == "2019-12-31", geo_value =="al")
revision_tb <- revision_summary(epi_arch, drop_nas = TRUE)
revision_tb\link{"time_to_0.8_final"} \%>\%
revision_tb \%>\% select(-max_rel_change, -number_of_revisions)
epi_arch$DT \%>\% filter(time_value =="2020-01-01", geo_value == "nv")
epi_arch$DT \%>\% group_by(time_value, geo_value)
}
}
\examples{

revision_example <- revision_summary(archive_cases_dv_subset, percent_cli)

revision_example \%>\% arrange(desc(max_change))
}
