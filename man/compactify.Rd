% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/archive.R
\name{compactify}
\alias{compactify}
\title{Compactify}
\usage{
compactify(df, keys, tolerance = .Machine$double.eps^0.5)
}
\description{
This section describes the internals of how compactification works in an
\code{epi_archive()}. Compactification can potentially improve code speed or
memory usage, depending on your data.

works by shifting all rows except the version, then comparing values to see
if they've changed. We need to arrange in descending order, but note that
we don't need to group, since at least one column other than version has
changed, and so is kept.
}
\details{
In general, the last version of each observation is carried forward (LOCF) to
fill in data between recorded versions, and between the last recorded
update and the \code{versions_end}. One consequence is that the \code{DT} doesn't
have to contain a full snapshot of every version (although this generally
works), but can instead contain only the rows that are new or changed from
the previous version (see \code{compactify}, which does this automatically).
Currently, deletions must be represented as revising a row to a special
state (e.g., making the entries \code{NA} or including a special column that
flags the data as removed and performing some kind of post-processing), and
the archive is unaware of what this state is. Note that \code{NA}s \emph{can} be
introduced by \code{epi_archive} methods for other reasons, e.g., in
\code{\link{epix_fill_through_version}} and \code{\link{epix_merge}}, if requested, to
represent potential update data that we do not yet have access to; or in
\code{\link{epix_merge}} to represent the "value" of an observation before the
version in which it was first released, or if no version of that
observation appears in the archive data at all.
}
\keyword{internal}
