% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/outliers.R
\name{detect_outlr_stl}
\alias{detect_outlr_stl}
\title{Detect outliers based on an STL decomposition}
\usage{
detect_outlr_stl(
  x = seq_along(y),
  y,
  n_trend = 21,
  n_seasonal = 21,
  n_threshold = 21,
  seasonal_period = NULL,
  log_transform = FALSE,
  detect_negatives = FALSE,
  detection_multiplier = 2,
  min_radius = 0,
  replacement_multiplier = 0
)
}
\arguments{
\item{x}{Design points corresponding to the signal values \code{y}. Default is
\code{seq_along(y)} (that is, equally-spaced points from 1 to the length of
\code{y}).}

\item{y}{Signal values.}

\item{n_trend}{Number of time steps to use in the rolling window for trend.
Default is 21.}

\item{n_seasonal}{Number of time steps to use in the rolling window for
seasonality. Default is 21.}

\item{n_threshold}{Number of time steps to use in rolling window for the IQR
outlier thresholds.}

\item{seasonal_period}{Integer specifying period of seasonality. For example,
for daily data, a period 7 means weekly seasonality. The default is \code{NULL},
meaning that no seasonal term will be included in the STL decomposition.
If specified, it must be strictly larger than 1.}

\item{log_transform}{Should a log transform be applied before running outlier
detection? Default is \code{FALSE}. If \code{TRUE}, and zeros are present, then the
log transform will be padded by 1.}

\item{detect_negatives}{Should negative values automatically count as
outliers? Default is \code{FALSE}.}

\item{detection_multiplier}{Value determining how far the outlier detection
thresholds are from the rolling median, which are calculated as (rolling
median) +/- (detection multiplier) * (rolling IQR). Default is 2.}

\item{min_radius}{Minimum distance between rolling median and threshold, on
transformed scale. Default is 0.}

\item{replacement_multiplier}{Value determining how far the replacement
values are from the rolling median. The replacement is the original value
if it is within the detection thresholds, or otherwise it is rounded to the
nearest (rolling median) +/- (replacement multiplier) * (rolling IQR).
Default is 0.}
}
\value{
An tibble with number of rows equal to \code{length(y)} and columns
giving the outlier detection thresholds (\code{lower} and \code{upper}) and
replacement values from each detection method (\code{replacement}).
}
\description{
Detects outliers based on a seasonal-trend decomposition using LOESS (STL).
}
\details{
The STL decomposition is computed using the \code{feasts} package. Once
computed, the outlier detection method is analogous to the rolling median
method in \code{detect_outlr_rm()}, except with the fitted values and residuals
from the STL decomposition taking the place of the rolling median and
residuals to the rolling median, respectively.

The last set of arguments, \code{log_transform} through \code{replacement_multiplier},
are exactly as in \code{detect_outlr_rm()}.
}
\examples{
# Detects outliers based on a seasonal-trend decomposition using LOESS
incidence_num_outlier_example \%>\%
  dplyr::select(geo_value, time_value, cases) \%>\%
  as_epi_df() \%>\%
  group_by(geo_value) \%>\%
  mutate(outlier_info = detect_outlr_stl(
    x = time_value, y = cases,
    seasonal_period = 7
  )) \%>\% # weekly seasonality for daily data
  unnest(outlier_info)
}
